7
(quote ())
#f
(quote (1 2 3 4))
(let ((t.1 10)) (if t.1 t.1 #f))
(if #t (if 45 7 #f) #f)
(+ 4 5)
(- 1 4)
(* 7 9)
(cons 1 (quote ()))
(car (quote (1 2)))
(cdr (quote (1 2)))
(if #t 1 2)
(pair? (quote (1 2)))
(pair? (quote ()))
(boolean? #f)
(boolean? 7)
(null? (quote ()))
(null? (quote (1 2)))
(number? 1234)
(number? (quote ()))
(procedure? (lambda (x) x))
(procedure? 7)
(<= 1 8)
(<= 8 1)
(<= 1 1)
(< 8 1)
(< 1 8)
(= 1 1)
(= 1 0)
(>= 8 1)
(>= 1 8)
(>= 1 1)
(> 8 1)
(> 1 8)
(if #f #f #t)
(if 10 #f #t)
(let ((x 5)) (begin (* 3 x) x))
(let ((x 5)) (begin (+ 3 x) x))
(let ((x 5)) (begin (- 3 x) x))
(let ((x (cons 1 5))) (begin (car x) x))
(let ((x (cons 1 5))) (begin (cdr x) x))
(let ((x 1) (y 5)) (begin (cons x y) x))
(begin (void) 5)
(if (+ 3 5) (quote 7) 8)
(if (if (* 3 5) #f #t) (quote 7) 8)
(if (- 3 5) (quote 7) 8)
(if (cons 3 5) 7 8)
(if (car (cons #t #f)) 7 8)
(if (cdr (cons #t #f)) 7 8)
(if (void) 7 8)
(< 7 8)
(let () (<= 7 8))
(= 7 8)
(letrec () (>= 7 8))
(> 7 8)
(let () (boolean? #f))
(if #t #f #t)
(let ((x (cons 1 (quote ()))) (y (cons 1 (quote ()))))
  (eq? x y))
(number? 7)
(null? (quote ()))
(letrec () (pair? (cons 1 (quote ()))))
(let ((t.2 5))
  (if t.2
      t.2
      (let ((t.3 7))
        (if t.3
            t.3
            (let ((t.4 #f))
              (if t.4 t.4 (let ((t.5 10)) (if t.5 t.5 11))))))))
(if #t (if #t (if 10 100 #f) #f) #f)
(letrec () (begin (< 7 8) 7))
(begin (<= (quote 7) (quote 8)) (quote 7))
(letrec () (begin (= 7 8) 7))
(begin (>= 7 8) 7)
(letrec () (begin (> 7 8) 8))
(letrec () (begin (boolean? #f) 9))
(letrec ()
  (let ((x (cons 1 (quote ()))) (y (cons 1 (quote ()))))
    (begin (eq? x y) 10)))
(letrec () (begin (number? 7) 10))
(let () (begin (null? (quote ())) 15))
(letrec () (begin (pair? (cons 1 (quote ()))) 20))
(let ((x (quote (1 2)))) (eq? x x))
(let ((x (quote (1 2))) (y (quote (1 2)))) (eq? x y))
(+ (let ((x 7) (y 2))
     (if (if (= x 7) (< y 0) (<= 0 y)) 77 88))
   99)
(if (= (+ 7 (* 2 4)) (- 20 (+ (+ 1 1) (+ (+ 1 1) 1))))
    (+ 1 (+ 1 (+ 1 (+ 1 (+ 1 10)))))
    0)
(cons
  (let ((f (lambda (h v) (* h v))))
    (let ((k (lambda (x) (+ x 5))))
      (letrec ((x 15))
        (letrec ((g (lambda (x) (+ 1 x))))
          (k (g (let ((g 3)) (f g x))))))))
  (quote ()))
(let ((x (cons (quote 1) (quote ()))))
  (let ((x (cons (quote 2) x)))
    (let ((x (cons (quote 3) x)))
      (let ((x (cons (quote 4) x)))
        (let ((x (cons (quote 5) x))) x)))))
(let ((n 5))
  (let ((a 1))
    (let ((a (* a n)))
      (let ((n (- n 1)))
        (let ((a (* a n)))
          (let ((n (- n 1)))
            (let ((a (* a n)))
              (let ((n (- n 1))) (let ((a (* a n))) a)))))))))
(letrec ((a (lambda (u v w x)
              (if (= u 0) (b v w x) (a (- u 1) v w x))))
         (b (lambda (q r x) (let ((p (* q r))) (e (* q r) p x))))
         (c (lambda (x) (* 5 x)))
         (e (lambda (n p x)
              (if (= n (quote 0)) (c p) (o (- n 1) p x))))
         (o (lambda (n p x) (if (= 0 n) (c x) (e (- n 1) p x)))))
  (let ((x 5)) (a 3 2 1 x)))
((letrec ((length (lambda (ptr)
                    (if (null? ptr) 0 (+ 1 (length (cdr ptr)))))))
   length)
  (quote (5 10 11 5 15)))
(letrec ((count-leaves (lambda (p)
                         (if (pair? p)
                             (+ (count-leaves (car p))
                                (count-leaves (cdr p)))
                             1))))
  (count-leaves
    (cons
      (cons (quote 0) (cons (quote 0) (quote 0)))
      (cons
        (cons
          (cons (cons (quote 0) (cons (quote 0) (quote 0))) (quote 0))
          (quote 0))
        (cons
          (cons
            (cons (quote 0) (quote 0))
            (cons (quote 0) (cons (quote 0) (quote 0))))
          (cons (cons (quote 0) (quote 0)) (quote 0)))))))
(letrec ((add1 (lambda (n) (+ n 1)))
         (map (lambda (f ls)
                (if (null? ls)
                    (quote ())
                    (cons (f (car ls)) (map f (cdr ls))))))
         (sum (lambda (ls)
                (if (null? ls) 0 (+ (car ls) (sum (cdr ls)))))))
  (let ((ls (quote (5 4 3 2 1))))
    (let ((ls (cons
                (quote 10)
                (cons
                  (quote 9)
                  (cons (quote 8) (cons (quote 7) (cons (quote 6) ls)))))))
      (sum (map add1 ls)))))
(letrec ((list-ref (lambda (ls offset)
                     (if (= offset 0)
                         (car ls)
                         (list-ref (cdr ls) (- offset 1)))))
         (add (lambda (v w) (+ v w)))
         (sub (lambda (v w) (- v w)))
         (mult (lambda (v w) (* v w)))
         (expt (lambda (v w) (if (= w 0) 1 (* v (expt v (- w 1))))))
         (selector (lambda (op* sel rand1 rand2)
                     (if (null? sel)
                         0
                         (cons
                           ((list-ref op* (car sel))
                             (car rand1)
                             (car rand2))
                           (selector
                             op*
                             (cdr sel)
                             (cdr rand1)
                             (cdr rand2))))))
         (sum (lambda (ls)
                (if (pair? ls) (+ (car ls) (sum (cdr ls))) 0))))
  (sum (selector
         (cons add (cons sub (cons mult (cons expt (quote ())))))
         (quote (2 0 1 3 2))
         (quote (5 9 10 2 3))
         (quote (3 1 3 3 8)))))
(letrec ((thunk-num (lambda (n) (lambda () n)))
         (force (lambda (th) (th)))
         (add-ths (lambda (th1 th2 th3 th4)
                    (+ (+ (force th1) (force th2))
                       (+ (force th3) (force th4))))))
  (add-ths
    (thunk-num 5)
    (thunk-num 17)
    (thunk-num 7)
    (thunk-num 9)))
(letrec ((x 7) (f (lambda () x))) (f))
((lambda (y) ((lambda (f) (f (f y))) (lambda (y) y))) 4)
(let ((double (lambda (a) (+ a a)))) (double 10))
(let ((t #t) (f #f))
  (letrec ((even (lambda (x) (if (= x 0) t (odd (- x 1)))))
           (odd (lambda (x) (if (= x 0) f (even (- x 1))))))
    (odd 13)))
(letrec ((remq (lambda (x ls)
                 (if (null? ls)
                     (quote ())
                     (if (eq? (car ls) x)
                         (remq x (cdr ls))
                         (cons (car ls) (remq x (cdr ls))))))))
  (remq 3 (quote (3 1 3))))
(letrec ((gcd (lambda (x y)
                (if (= y 0)
                    x
                    (gcd (if (> x y) (- x y) x) (if (> x y) y (- y x)))))))
  (gcd 1071 1029))
(letrec ((sub1 (lambda (n) (- n 1)))
         (fib (lambda (n)
                (if (= 0 n)
                    0
                    (if (= 1 n)
                        1
                        (+ (fib (sub1 n)) (fib (sub1 (sub1 n)))))))))
  (fib 10))
(letrec ((ack (lambda (m n)
                (if (= m 0)
                    (+ n 1)
                    (if (if (> m 0) (= n 0) #f)
                        (ack (- m 1) 1)
                        (ack (- m 1) (ack m (- n 1))))))))
  (ack 2 4))
(letrec ((fib (lambda (n)
                (letrec ((fib (lambda (n a b)
                                (if (= n 0) a (fib (- n 1) b (+ b a))))))
                  (fib n 0 1)))))
  (fib 5))
((((((lambda (x)
       (lambda (y)
         (lambda (z)
           (lambda (w) (lambda (u) (+ x (+ y (+ z (+ w u)))))))))
      5)
     6)
    7)
   8)
  9)
(let ((t #t) (f #f))
  (let ((bools (cons t f))
        (id (lambda (x) (if (if x #f #t) f t))))
    (letrec ((even (lambda (x)
                     (if (= x 0) (id (car bools)) (odd (- x 1)))))
             (odd (lambda (y)
                    (if (= y 0) (id (cdr bools)) (even (- y 1))))))
      (odd 5))))
(let ((x 7) (y 4))
  (let ((t.6 (if (number? x)
                 (if (= x 4) (if (number? y) (= y 7) #f) #f)
                 #f)))
    (if t.6
        t.6
        (if (number? x)
            (if (= x 7) (if (number? y) (= y 4) #f) #f)
            #f))))
(letrec ((f (lambda (x) (+ 1 x)))
         (g (lambda (x) (- x 1)))
         (t (lambda (x) (- x 1)))
         (j (lambda (x) (- x 1)))
         (i (lambda (x) (- x 1)))
         (h (lambda (x) (- x 1))))
  (let ((x 80))
    (let ((a (f x)) (b (g x)) (c (h (i (j (t x))))))
      (* a (* b (+ c 0))))))
(let ((f (lambda (x) (+ 1 x))) (g (lambda (x) (- x 1))))
  (let ((x 80))
    (let ((a (f x))
          (b (g x))
          (c (letrec ((h (lambda (x) (- x 1))))
               (h (letrec ((i (lambda (x) (- x 1))))
                    (i (letrec ((t (lambda (x) (- x 1)))
                                (j (lambda (x) (- x 1))))
                         (j (t x)))))))))
      (* a (* b (+ c 0))))))
(letrec ((fact (lambda (n)
                 (if (= n 0)
                     1
                     (let ((t (- n 1))) (let ((t (fact t))) (* n t)))))))
  (fact 10))
(letrec ((fib (lambda (n k)
                (if (let ((t.7 (= n 0))) (if t.7 t.7 (= n 1)))
                    (k 1)
                    (fib (- n 1)
                         (lambda (w)
                           (fib (- n 2) (lambda (v) (k (+ w v))))))))))
  (fib 10 (lambda (x) x)))
(letrec ((num-list? (lambda (ls)
                      (if (null? ls)
                          #t
                          (if (number? (car ls))
                              (num-list? (cdr ls))
                              #f))))
         (length (lambda (ls)
                   (if (null? ls) 0 (+ (length (cdr ls)) 1))))
         (dot-prod (lambda (ls1 ls2)
                     (if (if (null? ls1) (null? ls2) #f)
                         0
                         (+ (* (car ls1) (car ls2))
                            (dot-prod (cdr ls1) (cdr ls2)))))))
  (let ((ls1 (quote (1 2 3 4 5))) (ls2 (quote (5 4 3 2 1))))
    (if (if (if (eq? (num-list? ls1) #f) #f #t)
            (if (if (eq? (num-list? ls2) #f) #f #t)
                (= (length ls1) (length ls2))
                #f)
            #f)
        (dot-prod ls1 ls2)
        #f)))
(letrec ((num-list? (lambda (ls)
                      (if (null? ls)
                          #t
                          (if (number? (car ls))
                              (num-list? (cdr ls))
                              #f))))
         (list-product (lambda (ls)
                         (if (null? ls)
                             1
                             (* (car ls) (list-product (cdr ls)))))))
  (let ((ls (quote (1 2 3 4 5))))
    (if (num-list? ls) (list-product ls) #f)))
(letrec ((f (lambda (x y)
              (if x (h (+ x y)) (g (+ x 1) (+ y 1)))))
         (g (lambda (u v)
              (let ((a (+ u v)) (b (* u v)))
                (letrec ((e (lambda (d)
                              (let ((p (cons a b)))
                                (letrec ((q (lambda (m)
                                              (if (< m u)
                                                  (f m d)
                                                  (h (car p))))))
                                  (q (f a b)))))))
                  (e u)))))
         (h (lambda (w) w)))
  (f 4 5))
(letrec ((curry-list (lambda (x)
                       (lambda (y)
                         (lambda (z)
                           (lambda (w)
                             (cons
                               x
                               (cons y (cons z (cons w (quote ()))))))))))
         (append (lambda (ls1 ls2)
                   (if (null? ls1)
                       ls2
                       (cons (car ls1) (append (cdr ls1) ls2))))))
  (append
    ((((curry-list 1) 2) 3) 4)
    ((((curry-list 5) 6) 7) 8)))
(if (+ ((if (if (cons (quote 1) (quote (2))) #f #t)
            (quote #t)
            (letrec ((f.1 (quote 3))
                     (f.2 (lambda (x.3) (+ x.3 (quote 4)))))
              f.2))
         (quote 5))
       (quote 6))
    (quote #f)
    #f)
(let ((a 5) (b 4))
  (letrec ((c (lambda (d e) (* d e)))
           (f (lambda (g h) (cons g h))))
    (if (let ((t.8 (> (c a b) 15))) (if t.8 t.8 (= (c a b) 20)))
        (f a b)
        (void))))
(let ((begin (lambda (x y) (+ x y)))
      (set! (lambda (x y) (* x y))))
  (let ((lambda (lambda (x) (begin 1 x))))
    (let ((lambda (lambda (set! 1 2))))
      (let ((let (set! lambda lambda)))
        (begin let (set! lambda (set! 4 (begin 2 3))))))))
(let ((x (quote (4 5 6))) (y (quote (7 8 9))))
  (cons
    1
    (cons
      2
      (cons
        3
        (cons
          (car x)
          (cons (car (cdr x)) (cons (car (cdr (cdr x))) y)))))))
(let ((a 1))
  (letrec ((add1 (lambda (b) (+ b 1)))
           (sub1 (lambda (b) (- b 1))))
    (let ((c (lambda (a)
               (if (let ((t.9 (if (= a 1) #f #t)))
                     (if t.9 t.9 (if (> a 1) (< a 4) #f)))
                   (add1 a)
                   (sub1 a)))))
      (let ((d (c a)) (e (c (add1 a))) (f (c (sub1 a))))
        (cons d (cons e (cons f (quote ()))))))))
(let ((foo (lambda (lambda) (lambda))))
  (let ((lambda foo) (bar (lambda () #t))) (foo bar)))
(letrec ((merge (lambda (ls ls2)
                  (if (null? ls)
                      ls2
                      (if (null? ls2)
                          ls
                          (if (< (car ls) (car ls2))
                              (cons (car ls) (merge (cdr ls) ls2))
                              (cons (car ls2) (merge ls (cdr ls2))))))))
         (sort (lambda (ls)
                 (if (null? ls)
                     ls
                     (if (null? (cdr ls))
                         ls
                         (let ((halves (halves
                                         ls
                                         (quote ())
                                         (quote ())
                                         #t)))
                           (let ((first (car halves))
                                 (second (car (cdr halves))))
                             (merge (sort first) (sort second))))))))
         (halves (lambda (ls first second first?)
                   (if (null? ls)
                       (cons first (cons second (quote ())))
                       (if first?
                           (halves
                             (cdr ls)
                             (cons (car ls) first)
                             second
                             #f)
                           (halves
                             (cdr ls)
                             first
                             (cons (car ls) second)
                             #t)))))
         (pend (lambda (ls ls2)
                 (if (null? ls) ls2 (cons (car ls) (pend (cdr ls) ls2))))))
  (pend
    (sort (quote (1 5 5 8 2 3 9)))
    (sort (quote (5 9 5 7 7 8 7)))))
(letrec ((depth (lambda (ls)
                  (if (null? ls)
                      1
                      (if (pair? (car ls))
                          (let ((l ((lambda (m) (+ m 1)) (depth (car ls))))
                                (r (depth (cdr ls))))
                            (if (< l r) r l))
                          (depth (cdr ls)))))))
  (depth (quote (1 2 (3 (4 (5 (6 7))))))))
((lambda (x)
   (if (if (eq? x 5)
           x
           (if x
               (if 1
                   (if 2
                       (if 3
                           (if 4
                               (let ((t.10 6))
                                 (if t.10
                                     t.10
                                     (let ((t.11 7))
                                       (if t.11
                                           t.11
                                           (let ((t.12 8))
                                             (if t.12 t.12 9))))))
                               #f)
                           #f)
                       #f)
                   #f)
               #f))
       3
       (void)))
  4)
(letrec ((F (lambda (func-arg)
              (lambda (n) (if (= n 0) 1 (* n (func-arg (- n 1))))))))
  (letrec ((Y (lambda (X)
                ((lambda (procedure)
                   (X (lambda (arg) ((procedure procedure) arg))))
                  (lambda (procedure)
                    (X (lambda (arg) ((procedure procedure) arg))))))))
    (letrec ((fact (Y F))) (fact 5))))
(letrec ((extend (lambda (num alist)
                   (if (null? alist)
                       (cons (cons num 1) (quote ()))
                       (if (= num (car (car alist)))
                           (cons
                             (cons num (+ 1 (cdr (car alist))))
                             (cdr alist))
                           (cons (car alist) (extend num (cdr alist)))))))
         (loop (lambda (ls alist)
                 (if (null? ls)
                     alist
                     (loop (cdr ls) (extend (car ls) alist))))))
  (loop (quote (1 3 4 5 5 4 5 2 3 4 1)) (quote ())))
(letrec
	((fact
      	(lambda (n)
          	(if (= n 0)
				1
                (* n (fact (- n 1)))))))
	(fact 5))
(let ((x 1) (y x)) (+ x y))
(let
	((fact
      	(lambda (n)
          	(if (= n 0)
				1
                (* n (fact (- n 1)))))))
	(fact 5))
let
letrec
(exit)